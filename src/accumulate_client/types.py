# AUTOGENERATED â€“ DO NOT EDIT

"""
Type definitions for Accumulate API

This module provides Pydantic model definitions for all Accumulate Protocol types,
including accounts, transactions, and API request/response structures.
Generated from the official Accumulate Protocol specification.
"""

from __future__ import annotations
from pydantic import BaseModel
from typing import Optional, List, Dict, Union, Any
from datetime import datetime

from .runtime.url import AccountUrl

class UnknownAccount(BaseModel):
    """Protocol type: UnknownAccount"""
    url: AccountUrl  # *url

class UnknownSigner(BaseModel):
    """Protocol type: UnknownSigner"""
    url: AccountUrl  # *url
    version: int  # uvarint

class LiteIdentity(BaseModel):
    """Protocol type: LiteIdentity"""
    url: AccountUrl  # *url
    credit_balance: int  # uvarint
    last_used_on: int  # uvarint

class LiteTokenAccount(BaseModel):
    """Protocol type: LiteTokenAccount"""
    url: AccountUrl  # *url
    token_url: AccountUrl  # *url
    balance: int  # bigint
    lock_height: int  # uint

class LiteDataAccount(BaseModel):
    """Protocol type: LiteDataAccount"""
    url: AccountUrl  # *url

class ADI(BaseModel):
    """Protocol type: ADI"""
    url: AccountUrl  # *url
    account_auth: AccountAuth  # AccountAuth

class TokenAccount(BaseModel):
    """Protocol type: TokenAccount"""
    url: AccountUrl  # *url
    account_auth: AccountAuth  # AccountAuth
    token_url: AccountUrl  # *url
    balance: int  # bigint

class KeyBook(BaseModel):
    """Protocol type: KeyBook"""
    url: AccountUrl  # *url
    book_type: BookType  # BookType
    account_auth: AccountAuth  # AccountAuth
    page_count: int  # uvarint

class KeyPage(BaseModel):
    """Protocol type: KeyPage"""
    key_book: AccountUrl  # *url
    url: AccountUrl  # *url
    credit_balance: int  # uvarint
    accept_threshold: int  # uvarint
    reject_threshold: int  # uvarint
    response_threshold: int  # uvarint
    block_threshold: int  # uvarint
    version: int  # uvarint
    keys: List[KeySpec]  # []*KeySpec
    transaction_blacklist: AllowedTransactions | None = None  # *AllowedTransactions

class DataAccount(BaseModel):
    """Protocol type: DataAccount"""
    url: AccountUrl  # *url
    account_auth: AccountAuth  # AccountAuth
    entry: DataEntry | None = None  # DataEntry

class TokenIssuer(BaseModel):
    """Protocol type: TokenIssuer"""
    url: AccountUrl  # *url
    account_auth: AccountAuth  # AccountAuth
    symbol: str  # string
    precision: int  # uvarint
    properties: AccountUrl  # *url
    issued: int  # bigint
    supply_limit: int | None = None  # *bigint

class Object(BaseModel):
    """Protocol type: Object"""
    type: ObjectType  # ObjectType
    chains: List[ChainMetadata]  # []ChainMetadata
    pending: TxIdSet  # TxIdSet

class ChainMetadata(BaseModel):
    """Protocol type: ChainMetadata"""
    name: str  # string
    type: ChainType  # ChainType

class BlockEntry(BaseModel):
    """Protocol type: BlockEntry"""
    account: AccountUrl  # *url
    chain: str  # string
    index: int  # uint

class AccountAuth(BaseModel):
    """Protocol type: AccountAuth"""
    authorities: List[AuthorityEntry]  # []AuthorityEntry

class AuthorityEntry(BaseModel):
    """Protocol type: AuthorityEntry"""
    url: AccountUrl  # *url
    disabled: bool  # bool

class AnchorMetadata(BaseModel):
    """Protocol type: AnchorMetadata"""
    account: AccountUrl  # *url
    index: int  # uvarint
    source_index: int  # uvarint
    source_block: int  # uvarint
    entry: bytes  # bytes

class AcmeOracle(BaseModel):
    """Protocol type: AcmeOracle"""
    price: int  # uvarint

class IndexEntry(BaseModel):
    """represents an entry in an index chain"""
    source: int  # uint
    anchor: int  # uint
    block_index: int  # uint
    block_time: datetime  # *time
    root_index_index: int  # uint

class AccumulateDataEntry(BaseModel):
    """Protocol type: AccumulateDataEntry"""
    data: List[bytes]  # []bytes

class DoubleHashDataEntry(BaseModel):
    """Protocol type: DoubleHashDataEntry"""
    data: List[bytes]  # []bytes

class FactomDataEntryWrapper(BaseModel):
    """Protocol type: FactomDataEntryWrapper"""
    factom_data_entry: FactomDataEntry  # FactomDataEntry

class FactomDataEntry(BaseModel):
    """Protocol type: FactomDataEntry"""
    account_id: bytes  # hash
    data: bytes  # bytes
    ext_ids: List[bytes]  # []bytes

class TxIdSet(BaseModel):
    """Protocol type: TxIdSet"""
    entries: List[str]  # []*txid

class TokenRecipient(BaseModel):
    """Protocol type: TokenRecipient"""
    url: AccountUrl  # *url
    amount: int  # bigint

class CreditRecipient(BaseModel):
    """Protocol type: CreditRecipient"""
    url: AccountUrl  # *url
    amount: int  # uint

class ChainParams(BaseModel):
    """Protocol type: ChainParams"""
    data: bytes  # bytes
    is_update: bool  # bool

class KeySpecParams(BaseModel):
    """Protocol type: KeySpecParams"""
    key_hash: bytes  # bytes
    delegate: AccountUrl | None = None  # *url

class KeySpec(BaseModel):
    """Protocol type: KeySpec"""
    public_key_hash: bytes  # bytes
    last_used_on: int  # uvarint
    delegate: AccountUrl  # *url

class NetworkGlobals(BaseModel):
    """Protocol type: NetworkGlobals"""
    operator_accept_threshold: Rational  # Rational
    validator_accept_threshold: Rational  # Rational
    major_block_schedule: str  # string
    anchor_empty_blocks: bool  # bool
    fee_schedule: FeeSchedule  # *FeeSchedule
    limits: NetworkLimits  # *NetworkLimits

class FeeSchedule(BaseModel):
    """Protocol type: FeeSchedule"""
    create_identity_sliding: List[Fee]  # []Fee
    create_sub_identity: Fee  # Fee
    bare_identity_discount: Fee  # Fee

class NetworkLimits(BaseModel):
    """Protocol type: NetworkLimits"""
    data_entry_parts: int  # uint
    account_authorities: int  # uint
    book_pages: int  # uint
    page_entries: int  # uint
    identity_accounts: int  # uint
    pending_major_blocks: int  # uint
    events_per_block: int  # uint

class Rational(BaseModel):
    """Protocol type: Rational"""
    numerator: int  # uint
    denominator: int  # uint

class NetworkDefinition(BaseModel):
    """Protocol type: NetworkDefinition"""
    network_name: str  # string
    version: int  # uint
    partitions: List[PartitionInfo]  # []*PartitionInfo
    validators: List[ValidatorInfo]  # []*ValidatorInfo

class PartitionInfo(BaseModel):
    """Protocol type: PartitionInfo"""
    id: str  # string
    type: PartitionType  # PartitionType

class ValidatorInfo(BaseModel):
    """Protocol type: ValidatorInfo"""
    public_key: bytes  # bytes
    public_key_hash: bytes  # hash
    operator: AccountUrl  # *url
    partitions: List[ValidatorPartitionInfo]  # []*ValidatorPartitionInfo

class ValidatorPartitionInfo(BaseModel):
    """Protocol type: ValidatorPartitionInfo"""
    id: str  # string
    active: bool  # bool

class RoutingTable(BaseModel):
    """Protocol type: RoutingTable"""
    overrides: List[RouteOverride]  # []RouteOverride
    routes: List[Route]  # []Route

class Route(BaseModel):
    """Protocol type: Route"""
    length: int  # uint
    value: int  # uint
    partition: str  # string

class RouteOverride(BaseModel):
    """Protocol type: RouteOverride"""
    account: AccountUrl  # *url
    partition: str  # string

class TokenIssuerProof(BaseModel):
    """Protocol type: TokenIssuerProof"""
    transaction: CreateToken  # *CreateToken
    receipt: Any  # *merkle.Receipt

class AnnotatedReceipt(BaseModel):
    """is a [merkle.Receipt] annotated with the account and chain it originates from"""
    receipt: Any  # *merkle.Receipt
    anchor: AnchorMetadata  # *AnchorMetadata

class MetricsRequest(BaseModel):
    """Protocol type: MetricsRequest"""
    metric: str  # string
    duration: int  # duration

class MetricsResponse(BaseModel):
    """Protocol type: MetricsResponse"""
    value: Any  # any

class TransactionResultSet(BaseModel):
    """Protocol type: TransactionResultSet"""
    results: List[TransactionStatus]  # []*TransactionStatus

class SyntheticOrigin(BaseModel):
    """Protocol type: SyntheticOrigin"""
    cause: str  # *txid
    source: AccountUrl  # *url
    initiator: AccountUrl  # *url
    fee_refund: int  # uint
    index: int  # uint

class SystemLedger(BaseModel):
    """Protocol type: SystemLedger"""
    url: AccountUrl  # *url
    index: int  # uint
    timestamp: datetime  # time
    acme_burnt: int  # bigint
    pending_updates: List[NetworkAccountUpdate]  # []NetworkAccountUpdate
    anchor: AnchorBody  # AnchorBody
    executor_version: ExecutorVersion | None = None  # ExecutorVersion
    bvn_executor_versions: List[PartitionExecutorVersion]  # []*PartitionExecutorVersion

class SyntheticLedger(BaseModel):
    """Protocol type: SyntheticLedger"""
    url: AccountUrl  # *url
    sequence: List[PartitionSyntheticLedger]  # []*PartitionSyntheticLedger

class AnchorLedger(BaseModel):
    """Protocol type: AnchorLedger"""
    url: AccountUrl  # *url
    minor_block_sequence_number: int  # uint
    major_block_index: int  # uint
    major_block_time: datetime  # time
    pending_major_block_anchors: List[AccountUrl]  # []*url
    sequence: List[PartitionSyntheticLedger]  # []*PartitionSyntheticLedger

class BlockLedger(BaseModel):
    """Protocol type: BlockLedger"""
    url: AccountUrl  # *url
    index: int  # uint
    time: datetime  # time
    entries: List[BlockEntry]  # []*BlockEntry

class NetworkAccountUpdate(BaseModel):
    """Protocol type: NetworkAccountUpdate"""
    name: str  # string
    body: TransactionBody  # TransactionBody

class PartitionAnchor(BaseModel):
    """Protocol type: PartitionAnchor"""
    source: AccountUrl  # *url
    major_block_index: int  # uint
    minor_block_index: int  # uvarint
    root_chain_index: int  # uvarint
    root_chain_anchor: bytes  # hash
    state_tree_anchor: bytes  # hash

class PartitionAnchorReceipt(BaseModel):
    """Protocol type: PartitionAnchorReceipt"""
    anchor: PartitionAnchor  # *PartitionAnchor
    root_chain_receipt: Any  # *merkle.Receipt

class PartitionSyntheticLedger(BaseModel):
    """Protocol type: PartitionSyntheticLedger"""
    url: AccountUrl  # *url
    produced: int  # uint
    received: int  # uint
    delivered: int  # uint
    pending: List[str]  # []*txid

class PartitionExecutorVersion(BaseModel):
    """Protocol type: PartitionExecutorVersion"""
    partition: str  # string
    version: ExecutorVersion  # ExecutorVersion

class TransactionHeader(BaseModel):
    """Protocol type: TransactionHeader"""
    principal: AccountUrl  # *url
    initiator: bytes  # hash
    memo: str | None = None  # string
    metadata: bytes | None = None  # bytes
    expire: ExpireOptions | None = None  # *ExpireOptions
    hold_until: HoldUntilOptions | None = None  # *HoldUntilOptions
    authorities: List[AccountUrl] | None = None  # []*url

class Transaction(BaseModel):
    """Protocol type: Transaction"""
    header: TransactionHeader  # TransactionHeader
    body: TransactionBody  # TransactionBody
    hash: bytes  # bytes
    header64bytes: bool  # bool
    body64bytes: bool  # bool

class HoldUntilOptions(BaseModel):
    """Protocol type: HoldUntilOptions"""
    minor_block: int | None = None  # uint

class ExpireOptions(BaseModel):
    """Protocol type: ExpireOptions"""
    at_time: datetime | None = None  # *time

class TransactionStatus(BaseModel):
    """Protocol type: TransactionStatus"""
    tx_id: str  # *txid
    code: errors2.Status  # errors2.Status
    remote: bool  # bool
    delivered: bool  # bool
    pending: bool  # bool
    failed: bool  # bool
    code_num: int  # uint
    error: Any  # *errors2.Error
    result: TransactionResult  # TransactionResult
    received: int  # uint
    initiator: AccountUrl  # *url
    signers: List[Signer]  # []Signer
    source_network: AccountUrl  # *url
    destination_network: AccountUrl  # *url
    sequence_number: int  # uint
    got_directory_receipt: bool  # bool
    proof: Any  # *merkle.Receipt
    anchor_signers: List[bytes]  # []bytes

class ChainQueryResponse(BaseModel):
    """API type: ChainQueryResponse"""
    type: str  # string
    main_chain: MerkleState  # *MerkleState
    chains: List[ChainState]  # []ChainState
    data: Any  # any
    chain_id: bytes  # bytes
    receipt: GeneralReceipt  # *GeneralReceipt
    last_block_time: datetime  # *time

class TransactionQueryResponse(BaseModel):
    """API type: TransactionQueryResponse"""
    type: str  # string
    main_chain: MerkleState  # *MerkleState
    data: Any  # any
    origin: AccountUrl  # *url
    transaction_hash: bytes  # bytes
    txid: str  # *txid
    transaction: Any  # *protocol.Transaction
    signatures: List[Any]  # []protocol.Signature
    status: Any  # *protocol.TransactionStatus
    produced: List[str]  # []*txid
    receipts: List[TxReceipt]  # []*TxReceipt
    signature_books: List[SignatureBook]  # []*SignatureBook
    last_block_time: datetime  # *time

class SignatureBook(BaseModel):
    """API type: SignatureBook"""
    authority: AccountUrl  # *url
    pages: List[SignaturePage]  # []*SignaturePage

class SignaturePage(BaseModel):
    """API type: SignaturePage"""
    signer: SignerMetadata  # SignerMetadata
    signatures: List[Any]  # []protocol.Signature

class SignerMetadata(BaseModel):
    """API type: SignerMetadata"""
    type: protocol.AccountType  # protocol.AccountType
    url: AccountUrl  # *url
    accept_threshold: int  # uint

class MinorBlock(BaseModel):
    """API type: MinorBlock"""
    block_index: int  # uint
    block_time: datetime  # *time

class MinorQueryResponse(BaseModel):
    """API type: MinorQueryResponse"""
    tx_count: int  # uint
    tx_ids: List[bytes]  # []bytes
    transactions: List[TransactionQueryResponse]  # []*TransactionQueryResponse
    last_block_time: datetime  # *time

class MajorQueryResponse(BaseModel):
    """API type: MajorQueryResponse"""
    major_block_index: int  # uint
    major_block_time: datetime  # *time
    minor_blocks: List[MinorBlock]  # []*MinorBlock
    last_block_time: datetime  # *time

class MerkleState(BaseModel):
    """API type: MerkleState"""
    height: int  # uvarint
    roots: List[bytes]  # []bytes

class MultiResponse(BaseModel):
    """API type: MultiResponse"""
    type: str  # string
    items: List[Any]  # []any
    start: int  # uvarint
    count: int  # uvarint
    total: int  # uvarint
    other_items: List[Any]  # []any
    last_block_time: datetime  # *time

class KeyPage(BaseModel):
    """API type: KeyPage"""
    version: int | None = None  # uvarint

class Signer(BaseModel):
    """API type: Signer"""
    public_key: bytes  # bytes
    timestamp: int  # uvarint
    url: AccountUrl  # *url
    version: int | None = None  # uint
    signature_type: protocol.SignatureType | None = None  # protocol.SignatureType
    use_simple_hash: bool | None = None  # bool

class TokenSend(BaseModel):
    """API type: TokenSend"""
    from_: AccountUrl  # *url
    to: List[TokenDeposit]  # []TokenDeposit

class TokenDeposit(BaseModel):
    """API type: TokenDeposit"""
    url: AccountUrl  # *url
    amount: int  # bigint
    txid: bytes  # bytes

class UrlQuery(BaseModel):
    """API type: UrlQuery"""
    url: AccountUrl  # *url

class KeyPageIndexQuery(BaseModel):
    """API type: KeyPageIndexQuery"""
    key: bytes  # bytes

class TxHistoryQuery(BaseModel):
    """API type: TxHistoryQuery"""
    scratch: bool | None = None  # bool

class QueryPagination(BaseModel):
    """API type: QueryPagination"""
    start: int | None = None  # uvarint
    count: int | None = None  # uvarint

class MinorBlocksQuery(BaseModel):
    """API type: MinorBlocksQuery"""
    tx_fetch_mode: TxFetchMode | None = None  # TxFetchMode
    block_filter_mode: BlockFilterMode | None = None  # BlockFilterMode

class QueryOptions(BaseModel):
    """API type: QueryOptions"""
    expand: bool | None = None  # bool
    height: int | None = None  # uvarint
    scratch: bool | None = None  # bool
    prove: bool | None = None  # bool
    include_remote: bool | None = None  # bool

class TxnQuery(BaseModel):
    """API type: TxnQuery"""
    txid: bytes | None = None  # bytes
    tx_id_url: str | None = None  # *txid
    wait: int | None = None  # duration
    ignore_pending: bool | None = None  # bool

class ChainIdQuery(BaseModel):
    """API type: ChainIdQuery"""
    chain_id: bytes  # bytes

class MetricsQuery(BaseModel):
    """API type: MetricsQuery"""
    metric: str  # string
    duration: int  # duration

class MetricsResponse(BaseModel):
    """API type: MetricsResponse"""
    value: Any  # any

class ExecuteRequest(BaseModel):
    """API type: ExecuteRequest"""
    envelope: Any  # *messaging.Envelope
    check_only: bool | None = None  # bool

class TxRequest(BaseModel):
    """API type: TxRequest"""
    check_only: bool | None = None  # bool
    is_envelope: bool | None = None  # bool
    origin: AccountUrl  # *url
    signer: Signer  # Signer
    signature: bytes  # bytes
    key_page: KeyPage  # KeyPage
    tx_hash: bytes | None = None  # bytes
    payload: Any  # any
    memo: str | None = None  # string
    metadata: bytes | None = None  # bytes

class TxResponse(BaseModel):
    """API type: TxResponse"""
    transaction_hash: bytes  # bytes
    txid: str  # *txid
    signature_hashes: List[bytes]  # []bytes
    simple_hash: bytes  # bytes
    code: int  # uvarint
    message: str  # string
    delivered: bool  # bool
    result: Any  # any
    last_block_time: datetime  # *time

class DataEntryQuery(BaseModel):
    """API type: DataEntryQuery"""
    url: AccountUrl  # *url
    entry_hash: bytes | None = None  # hash

class DataEntryQueryResponse(BaseModel):
    """API type: DataEntryQueryResponse"""
    entry_hash: bytes  # hash
    entry: protocol.DataEntry  # protocol.DataEntry
    tx_id: str  # *txid
    cause_tx_id: str  # *txid
    last_block_time: datetime  # *time

class ChainEntry(BaseModel):
    """API type: ChainEntry"""
    height: int  # uvarint
    entry: bytes  # bytes
    state: List[bytes]  # []bytes
    value: Any  # any

class StatusResponse(BaseModel):
    """API type: StatusResponse"""
    ok: bool  # bool
    bvn_height: int  # varint
    dn_height: int  # varint
    bvn_time: datetime  # time
    dn_time: datetime  # time
    last_directory_anchor_height: int  # uvarint
    bvn_root_hash: bytes  # hash
    dn_root_hash: bytes  # hash
    bvn_bpt_hash: bytes  # hash
    dn_bpt_hash: bytes  # hash

class VersionResponse(BaseModel):
    """API type: VersionResponse"""
    version: str  # string
    commit: str  # string
    version_is_known: bool  # bool
    is_test_net: bool  # bool

class DescriptionResponse(BaseModel):
    """API type: DescriptionResponse"""
    partition_id: str  # string
    network_type: protocol.PartitionType  # protocol.PartitionType
    network: NetworkDescription  # NetworkDescription
    network_anchor: bytes  # hash
    values: Any  # core.GlobalValues
    error: Any  # *errors2.Error

class SyntheticTransactionRequest(BaseModel):
    """API type: SyntheticTransactionRequest"""
    source: AccountUrl  # *url
    destination: AccountUrl  # *url
    sequence_number: int | None = None  # uint
    anchor: bool | None = None  # bool

class NetworkDescription(BaseModel):
    """API type: NetworkDescription"""
    id: str  # string
    partitions: List[PartitionDescription]  # []PartitionDescription

class PartitionDescription(BaseModel):
    """API type: PartitionDescription"""
    id: str  # string
    type: protocol.PartitionType  # protocol.PartitionType
    base_port: int  # int
    nodes: List[NodeDescription]  # []NodeDescription

class NodeDescription(BaseModel):
    """API type: NodeDescription"""
    address: str  # string
    type: config.NodeType  # config.NodeType

class ResponseKeyPageIndex(BaseModel):
    """API response: ResponseKeyPageIndex"""
    authority: AccountUrl  # *url
    signer: AccountUrl  # *url
    index: int  # uvarint
    last_block_time: datetime  # *time

class GeneralReceipt(BaseModel):
    """API response: GeneralReceipt"""
    local_block: int  # uvarint
    local_block_time: datetime  # *time
    directory_block: int  # uvarint
    major_block: int  # uint
    proof: Any  # merkle.Receipt
    error: str  # string

class TxReceipt(BaseModel):
    """API response: TxReceipt"""
    account: AccountUrl  # *url
    chain: str  # string

class ResponseDataEntry(BaseModel):
    """API response: ResponseDataEntry"""
    entry_hash: bytes  # hash
    entry: protocol.DataEntry  # protocol.DataEntry
    tx_id: str  # *txid
    cause_tx_id: str  # *txid
    last_block_time: datetime  # *time

class ResponseDataEntrySet(BaseModel):
    """API response: ResponseDataEntrySet"""
    data_entries: List[ResponseDataEntry]  # []ResponseDataEntry
    total: int  # uvarint
    last_block_time: datetime  # *time

class ChainState(BaseModel):
    """API response: ChainState"""
    name: str  # string
    type: protocol.ChainType  # protocol.ChainType
    height: int  # uvarint
    roots: List[bytes]  # []bytes


# Transaction payload classes for compatibility with tests
class CreateIdentityTransaction(BaseModel):
    """CreateIdentity transaction payload"""
    url: Optional[AccountUrl] = None
    key_book_url: Optional[AccountUrl] = None
    key_page_url: Optional[AccountUrl] = None
    public_key: Optional[bytes] = None
    key_hash: Optional[bytes] = None

class CreateTokenAccountTransaction(BaseModel):
    """CreateTokenAccount transaction payload"""
    url: Optional[AccountUrl] = None
    token_url: Optional[AccountUrl] = None
    scratch: Optional[bool] = None

class SendTokensTransaction(BaseModel):
    """SendTokens transaction payload"""
    to: Optional[List[TokenRecipient]] = None

class WriteDataTransaction(BaseModel):
    """WriteData transaction payload"""
    entry: Optional[Any] = None
    scratch: Optional[bool] = None

class AddCreditsTransaction(BaseModel):
    """AddCredits transaction payload"""
    recipient: Optional[AccountUrl] = None
    amount: Optional[int] = None
    oracle: Optional[int] = None


__all__ = ["UnknownAccount", "UnknownSigner", "LiteIdentity", "LiteTokenAccount", "LiteDataAccount", "ADI", "TokenAccount", "KeyBook", "KeyPage", "DataAccount", "TokenIssuer", "Object", "ChainMetadata", "BlockEntry", "AccountAuth", "AuthorityEntry", "AnchorMetadata", "AcmeOracle", "IndexEntry", "AccumulateDataEntry", "DoubleHashDataEntry", "FactomDataEntryWrapper", "FactomDataEntry", "TxIdSet", "TokenRecipient", "CreditRecipient", "ChainParams", "KeySpecParams", "KeySpec", "NetworkGlobals", "FeeSchedule", "NetworkLimits", "Rational", "NetworkDefinition", "PartitionInfo", "ValidatorInfo", "ValidatorPartitionInfo", "RoutingTable", "Route", "RouteOverride", "TokenIssuerProof", "AnnotatedReceipt", "MetricsRequest", "MetricsResponse", "TransactionResultSet", "SyntheticOrigin", "SystemLedger", "SyntheticLedger", "AnchorLedger", "BlockLedger", "NetworkAccountUpdate", "PartitionAnchor", "PartitionAnchorReceipt", "PartitionSyntheticLedger", "PartitionExecutorVersion", "TransactionHeader", "Transaction", "HoldUntilOptions", "ExpireOptions", "TransactionStatus", "ChainQueryResponse", "TransactionQueryResponse", "SignatureBook", "SignaturePage", "SignerMetadata", "MinorBlock", "MinorQueryResponse", "MajorQueryResponse", "MerkleState", "MultiResponse", "KeyPage", "Signer", "TokenSend", "TokenDeposit", "UrlQuery", "KeyPageIndexQuery", "TxHistoryQuery", "QueryPagination", "MinorBlocksQuery", "QueryOptions", "TxnQuery", "ChainIdQuery", "MetricsQuery", "MetricsResponse", "ExecuteRequest", "TxRequest", "TxResponse", "DataEntryQuery", "DataEntryQueryResponse", "ChainEntry", "StatusResponse", "VersionResponse", "DescriptionResponse", "SyntheticTransactionRequest", "NetworkDescription", "PartitionDescription", "NodeDescription", "ResponseKeyPageIndex", "GeneralReceipt", "TxReceipt", "ResponseDataEntry", "ResponseDataEntrySet", "ChainState", "CreateIdentityTransaction", "CreateTokenAccountTransaction", "SendTokensTransaction", "WriteDataTransaction", "AddCreditsTransaction"]