# GENERATED BY Accumulate gen-sdk. DO NOT EDIT.

"""JSON-RPC 2.0 client implementation"""

import asyncio
import json
import random
from typing import Any, Dict, List, Optional, Union

import aiohttp


class JsonRpcException(Exception):
    """JSON-RPC error exception"""

    def __init__(self, message: str, code: Optional[int] = None, data: Any = None):
        super().__init__(message)
        self.code = code
        self.data = data

    def __str__(self) -> str:
        if self.code is not None:
            return f"JsonRpcException({self.code}): {super().__str__()}"
        return f"JsonRpcException: {super().__str__()}"


class JsonRpcClient:
    """JSON-RPC 2.0 client"""

    def __init__(self, server_url: str, *, timeout: Optional[float] = None):
        """Initialize the client

        Args:
            server_url: The JSON-RPC endpoint URL
            timeout: Request timeout in seconds (default: 30)
        """
        self._server_url = server_url
        self._timeout = timeout or 30.0
        self._session: Optional[aiohttp.ClientSession] = None

    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create the HTTP session"""
        if self._session is None or self._session.closed:
            timeout = aiohttp.ClientTimeout(total=self._timeout)
            self._session = aiohttp.ClientSession(timeout=timeout)
        return self._session

    async def call(self, method: str, params: Any = None) -> Any:
        """Make a JSON-RPC call

        Args:
            method: The RPC method name
            params: The method parameters

        Returns:
            The result from the RPC call

        Raises:
            JsonRpcException: If the RPC call fails
        """
        request_id = random.randint(1, 1000000)
        request_data = {
            "jsonrpc": "2.0",
            "method": method,
            "id": request_id,
        }
        if params is not None:
            request_data["params"] = params

        session = await self._get_session()
        try:
            async with session.post(
                self._server_url,
                json=request_data,
                headers={"Content-Type": "application/json"},
            ) as response:
                if response.status != 200:
                    raise JsonRpcException(
                        f"HTTP {response.status}: {response.reason}",
                        code=response.status,
                    )

                response_data = await response.json()
        except aiohttp.ClientError as e:
            raise JsonRpcException(f"HTTP request failed: {e}")
        except json.JSONDecodeError as e:
            raise JsonRpcException(f"Invalid JSON response: {e}")

        if "error" in response_data:
            error = response_data["error"]
            raise JsonRpcException(
                error.get("message", "Unknown error"),
                code=error.get("code"),
                data=error.get("data"),
            )

        return response_data.get("result")

    async def batch(self, requests: List[Dict[str, Any]]) -> List[Any]:
        """Make a batch JSON-RPC call

        Args:
            requests: List of request dictionaries with 'method' and optional 'params'

        Returns:
            List of results from the RPC calls

        Raises:
            JsonRpcException: If any RPC call fails
        """
        batch_request = []
        for i, req in enumerate(requests):
            request_data = {
                "jsonrpc": "2.0",
                "method": req["method"],
                "id": i,
            }
            if "params" in req:
                request_data["params"] = req["params"]
            batch_request.append(request_data)

        session = await self._get_session()
        try:
            async with session.post(
                self._server_url,
                json=batch_request,
                headers={"Content-Type": "application/json"},
            ) as response:
                if response.status != 200:
                    raise JsonRpcException(
                        f"HTTP {response.status}: {response.reason}",
                        code=response.status,
                    )

                response_data = await response.json()
        except aiohttp.ClientError as e:
            raise JsonRpcException(f"HTTP request failed: {e}")
        except json.JSONDecodeError as e:
            raise JsonRpcException(f"Invalid JSON response: {e}")

        results = []
        for item in response_data:
            if "error" in item:
                error = item["error"]
                raise JsonRpcException(
                    error.get("message", "Unknown error"),
                    code=error.get("code"),
                    data=error.get("data"),
                )
            results.append(item.get("result"))

        return results

    async def close(self) -> None:
        """Close the HTTP session"""
        if self._session and not self._session.closed:
            await self._session.close()

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()